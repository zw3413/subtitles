# -*- coding: utf-8 -*-
"""subtitlex_0411.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/198BFSdK8K_V5HhR_Md4B4jMOP4_XAUiD
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# from google.colab import drive
# drive.mount('/content/drive', force_remount=True)
# !pip install streamlink
# !pip install "faster-whisper @ https://github.com/SYSTRAN/faster-whisper/archive/refs/tags/v1.0.1.tar.gz"
import requests
import json
serverIp = "https://api.subtitlex.xyz"
def remote_call(f, pl):
    headers = {
        "Content-Type": "application/json",
    }
    data = {
        "hashcode": "xxx",
        "request_id": "xxx",
        "device_ip": "0.0.0.0",
        "function": f,
        "params": pl,
    }
    try:
        response = requests.post(serverIp + "/common/allPurpose", headers=headers, data=json.dumps(data))
        if response.status_code == 200:
            return response.json()
        else:
            # TODO: 显示调用失败的消息给用户
            print(f"Call failed with status code: {response.status_code}")
            return None
    except requests.RequestException as e:
        # TODO: 显示调用失败的消息给用户
        print(f"Call failed: {e}")
        return None
def getSeedNeedProcess(type):
    pl = [type]
    result = remote_call('p_get_need_process',pl)
    if result['rc'] == '000':
      return json.loads(result['data'])
    else :
      return None
def SaveSeed(seed):
    try:
        url = serverIp+"/save_seed"
        #print("SaveSeed:")
        #print(seed)
        r = requests.post(url, json=seed,timeout=60)
        jData = json.loads(r.text)
        return jData
    except Exception as e:
        print(e)
        return
def SaveSubtitle(subtitle):
    try:
        url = serverIp+"/save_subtitle"
        #print("SaveSubtitle:")
        #print(subtitle)
        r = requests.post(url, json=subtitle,timeout=60)
        jData = json.loads(r.text)
        return jData
    except Exception as e:
        print(e)
        return

def upload_file(file_path, url):
    with open(file_path, 'rb') as file:
        files = {'file': file}
        response = requests.post(url, files=files)

        if response.status_code == 200:
            print("File uploaded successfully!")
        else:
            print("Failed to upload file. Status code:", response.status_code)
            print("Response:", response.text)

def PushSubtitleToServer(tgt_path, file_name):
    upload_url = serverIp+"/upload-files?filename="+file_name
    file_path = tgt_path
    upload_file(file_path, upload_url)

import os
import subprocess
filePath_prefix_video = '/content/file/video/'
os.makedirs(filePath_prefix_video, exist_ok=True)
FLV_afterfix = '.flv'
def downloadFlv(url, filePath, quality = 'worst'):
    threads = '8'
    origin = ''
    quality = quality # "worst"
    # fileName =  hashlib.md5(url.encode()).hexdigest() +FLV_afterfix
    # match = re.search(r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}", url)
    # if match != None:
    #     fileName = match.group(0)+FLV_afterfix
    #delete the file at filePath if exist
    if os.path.exists(filePath):
        os.remove(filePath)
    cmd = 'streamlink --retry-max 3 --retry-streams 10 --stream-segment-attempts 20 --stream-segment-timeout 60 --stream-timeout 120 --http-timeout 120 --stream-segment-threads '+threads+' -o "'+filePath+'" --http-header "User-Agent=Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.130 AOL/9.8 AOLBuild/4346.2019.US Safari/537.36" --http-header "Origin='+ origin +'" "hlsvariant://'+ url +'" '+quality
    print(cmd)
    #output = os.system(cmd)
    command_result  = subprocess.call(cmd)
    return command_result
    #return 0,fileName
# quality = 'worst'
# video_m3u8_url = r'https://surrit.com/0e779002-2042-4e42-9d59-c2780fabaaac/842x480/video.m3u8'
# output, flvPath = downloadFlv(video_m3u8_url,quality)
# print(output)
# print(flvPath)

from faster_whisper import WhisperModel
from datetime import timedelta, datetime
import torch
compute_type = "float16" if torch.cuda.is_available() else "int8"

model_size = 'large-v3' # "base" #
model_path = "/content/drive/MyDrive/cache/fast-whisper/"
device = "cuda" if torch.cuda.is_available() else "cpu"
print(device)
model = WhisperModel(
    #model_path,
    model_size,
    device = device ,
    compute_type= compute_type,
    local_files_only = False,
)
filePath_prefix_srt = '/content/file/subtitle/'
os.makedirs(filePath_prefix_srt, exist_ok=True)
SRT_afterfix = '.srt'

import sys
sys.path.append('/content/drive/MyDrive/Subtitles/pytool')
import utils
def transcribe_func(flvPath):
  segments, info = model.transcribe(
      filePath_prefix_video+flvPath,
      beam_size=5,
      vad_filter=True,
      task = "transcribe"
      )
  language = info.language
  file_name = flvPath.replace(FLV_afterfix, SRT_afterfix).replace('_worst','').replace('_best','')
  srtPath = filePath_prefix_srt + file_name
  if os.path.exists(srtPath):
      os.remove(srtPath)
  f = open(srtPath, "w", encoding='utf-8')
  lineCount = 0
  t_start = datetime.now()
  pt = ''
  for segment in segments :
      lineCount += 1
      f.write(str(lineCount)+"\n")
      s = utils.secondsToStr(segment.start)
      e = utils.secondsToStr(segment.end)
      f.write( s + ' --> ' + e +"\n")
      t = e.split(",",1)[0].replace(":","")[0:3]
      if t != pt:
          print(t, end=" ")
          pt= t
      f.write(segment.text)
      f.write("\n\n")
      lineCount = lineCount + 1
  f.flush()
  f.close()
  return srtPath, file_name, language
# srtPath, file_name = transcribe_func('0e779002-2042-4e42-9d59-c2780fabaaac.flv')
# print(srtPath)
# print(file_name)


import threading
import time
import queue
def executeDownload(q,lock):
    while True:
        with lock:
            while not q.empty():
                time.sleep(1)
        
        try:
            seed = getSeedNeedProcess("download_transcribe")
            if seed is None:
                break #结束生产者
            seed["id"] = str(seed["id"])
            video_m3u8_url = seed["video_m3u8_url"]
            uuid = seed["uuid"]
            quality = 'worst'
            print("开始下载" + seed["id"])
            flvPath = uuid + FLV_afterfix
            filePath = filePath_prefix_video + flvPath

            output = downloadFlv(video_m3u8_url,filePath,quality)
            if output != 0:
                print("下载失败"+str(output))
                seed["process_status"] = "8e"
                seed["err_msg"] =  "下载失败"+str(output)
                SaveSeed(seed)
            else:      
                q.put((seed, flvPath)) #放入队列
                print("下载完成 "+seed["id"])
        except Exception as e:
            print("下载异常"+str(e))
            seed["process_status"] = "8e"
            seed["err_msg"] = "下载异常" + str(e)
            SaveSeed(seed)
            

def executeTranscribe(q):
    while True:
        try:
            seed, flv_path = q.get(block=False) #非阻塞获取，如果队列为空则抛出异常
        except queue.Empty: #队列为空，等待1s再试
            time.sleep(1)
            continue
        
        if seed is None: #收到终止信号
            time.sleep(1)
            continue
        
        try:
            srtPath, file_name, language = transcribe_func(flv_path)
            PushSubtitleToServer(srtPath,file_name) #srt文件推送到服务器
            seed["srt_path"] = srtPath.replace(filePath_prefix_srt,"")
            seed["video_language"] = language
            seed["process_status"] = "8"
            seed["err_msg"]= ""
            SaveSeed(seed)
            subtitle = {}
            subtitle["language"] = utils.language_codes[language]
            subtitle["path"] = srtPath.replace(filePath_prefix_srt,"")
            subtitle["seed_id"] = seed["id"]
            subtitle["format"] = SRT_afterfix
            SaveSubtitle(subtitle)
            if os.path.exists(filePath_prefix_video+flv_path):
                os.remove(filePath_prefix_video+flv_path)
                print("移除视频文件"+filePath_prefix_video+flv_path)
        except Exception as e:
            print("转译异常"+str(e))
            seed["process_status"] = "8e"
            seed["err_msg"] = "转译异常" + str(e)
            SaveSeed(seed)
        finally:
            q.task_done()

def main():
    q = queue.Queue(maxsize = 1)
    lock = threading.Lock() #使用锁来同步对队列的检查
    

    
    download_thread = threading.Thread(target=executeDownload, args=(q, lock))
    #download_thread = threading.Thread(target=asyncio.run, args=(executeDownload(q,lock),))
    download_thread.start()
    
    transcribe_thread = threading.Thread(target=executeTranscribe, args=(q,))
    transcribe_thread.start()
    
    q.join()
    
    #发送中止信号给生产者线程
    with lock:
        q.put((None,None))
    
    #等待生产者线程结束
    download_thread.join()
    

if __name__ =="__main__":
    main()
