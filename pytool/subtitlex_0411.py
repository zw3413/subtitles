# -*- coding: utf-8 -*-
"""subtitlex_0411.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/198BFSdK8K_V5HhR_Md4B4jMOP4_XAUiD
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# from google.colab import drive
# drive.mount('/content/drive', force_remount=True)
# !pip install streamlink
# !pip install "faster-whisper @ https://github.com/SYSTRAN/faster-whisper/archive/refs/tags/v1.0.1.tar.gz"
# import requests
# import json
# serverIp = "https://api.subtitlex.xyz"
# def remote_call(f, pl):
#     headers = {
#         "Content-Type": "application/json",
#     }
#     data = {
#         "hashcode": "xxx",
#         "request_id": "xxx",
#         "device_ip": "0.0.0.0",
#         "function": f,
#         "params": pl,
#     }
#     try:
#         response = requests.post(serverIp + "/common/allPurpose", headers=headers, data=json.dumps(data))
#         if response.status_code == 200:
#             return response.json()
#         else:
#             # TODO: 显示调用失败的消息给用户
#             print(f"Call failed with status code: {response.status_code}")
#             return None
#     except requests.RequestException as e:
#         # TODO: 显示调用失败的消息给用户
#         print(f"Call failed: {e}")
#         return None
# def getSeedNeedProcess(type):
#     pl = [type]
#     result = remote_call('p_get_need_process',pl)
#     if result['rc'] == '000':
#       return json.loads(result['data'])
#     else :
#       return None
# def SaveSeed(seed):
#     try:
#         url = serverIp+"/save_seed"
#         #print("SaveSeed:")
#         #print(seed)
#         r = requests.post(url, json=seed,timeout=60)
#         jData = json.loads(r.text)
#         return jData
#     except Exception as e:
#         print(e)
#         return
# def SaveSubtitle(subtitle):
#     try:
#         url = serverIp+"/save_subtitle"
#         #print("SaveSubtitle:")
#         #print(subtitle)
#         r = requests.post(url, json=subtitle,timeout=60)
#         jData = json.loads(r.text)
#         return jData
#     except Exception as e:
#         print(e)
#         return
# 
# def upload_file(file_path, url):
#     with open(file_path, 'rb') as file:
#         files = {'file': file}
#         response = requests.post(url, files=files)
# 
#         if response.status_code == 200:
#             print("File uploaded successfully!")
#         else:
#             print("Failed to upload file. Status code:", response.status_code)
#             print("Response:", response.text)
# 
# def PushSubtitleToServer(tgt_path, file_name):
#     upload_url = serverIp+"/upload-files?filename="+file_name
#     file_path = tgt_path
#     upload_file(file_path, upload_url)

import os
filePath_prefix_video = '/content/file/video/'
os.makedirs(filePath_prefix_video, exist_ok=True)
FLV_afterfix = '.flv'
def downloadFlv(url, quality = 'worst', uuid = ''):
    threads = '8'
    origin = ''
    quality = quality # "worst"
    # fileName =  hashlib.md5(url.encode()).hexdigest() +FLV_afterfix
    # match = re.search(r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}", url)
    # if match != None:
    #     fileName = match.group(0)+FLV_afterfix
    fileName = uuid + FLV_afterfix
    filePath = filePath_prefix_video + fileName
    #delete the file at filePath if exist
    if os.path.exists(filePath):
        os.remove(filePath)
    cmd = 'streamlink --retry-max 3 --retry-streams 10 --stream-segment-attempts 20 --stream-segment-timeout 60 --stream-timeout 120 --http-timeout 120 --stream-segment-threads '+threads+' -o "'+filePath+'" --http-header "User-Agent=Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.130 AOL/9.8 AOLBuild/4346.2019.US Safari/537.36" --http-header "Origin='+ origin +'" "hlsvariant://'+ url +'" '+quality
    print(cmd)
    output = os.system(cmd)
    return output,fileName
# quality = 'worst'
# video_m3u8_url = r'https://surrit.com/0e779002-2042-4e42-9d59-c2780fabaaac/842x480/video.m3u8'
# output, flvPath = downloadFlv(video_m3u8_url,quality)
# print(output)
# print(flvPath)

from faster_whisper import WhisperModel
from datetime import timedelta, datetime
import torch
compute_type = "float16" if torch.cuda.is_available() else "int8"

model_size = 'large-v3' # "base" #
model_path = "/content/drive/MyDrive/cache/fast-whisper/"
device = "cuda" if torch.cuda.is_available() else "cpu"
print(device)
model = WhisperModel(
    model_path,
    device = device ,
    compute_type= compute_type,
    local_files_only = False,
)
filePath_prefix_srt = '/content/file/subtitle/'
os.makedirs(filePath_prefix_srt, exist_ok=True)
SRT_afterfix = '.srt'

import sys
sys.path.append('/content/drive/MyDrive/Subtitles/pytool')
import utils
def transcribe_func(flvPath):
  segments, info = model.transcribe(
      filePath_prefix_video+flvPath,
      beam_size=5,
      vad_filter=True,
      task = "transcribe"
      )
  language = info.language
  file_name = flvPath.replace(FLV_afterfix, SRT_afterfix).replace('_worst','').replace('_best','')
  srtPath = filePath_prefix_srt + file_name
  if os.path.exists(srtPath):
      os.remove(srtPath)
  f = open(srtPath, "w", encoding='utf-8')
  lineCount = 0
  t_start = datetime.now()
  pt = ''
  for segment in segments :
      lineCount += 1
      f.write(str(lineCount)+"\n")
      s = utils.secondsToStr(segment.start)
      e = utils.secondsToStr(segment.end)
      f.write( s + ' --> ' + e +"\n")
      t = e.split(",",1)[0].replace(":","")[0:3]
      if t != pt:
          print(t, end=" ")
          pt= t
      f.write(segment.text)
      f.write("\n\n")
      lineCount = lineCount + 1
  f.flush()
  f.close()
  return srtPath, file_name, language
# srtPath, file_name = transcribe_func('0e779002-2042-4e42-9d59-c2780fabaaac.flv')
# print(srtPath)
# print(file_name)

def executeDownload(seed,flvPath):
    try:
        seed["id"] = str(seed["id"])
        video_m3u8_url = seed["video_m3u8_url"]
        uuid = seed["uuid"]
        quality = 'worst'
        output, flvPath = downloadFlv(video_m3u8_url,quality,uuid)
        if output != 0:
            print("下载失败")
            seed["process_status"] = "8e"
            seed["err_msg"] =  "下载失败"+str(output)
            SaveSeed(seed)
            return
        print("下载完成 "+seed["id"])
        return flvPath
    except Exception as e:
        print("下载异常"+str(e))
        seed["process_status"] = "8e"
        seed["err_msg"] = "下载异常" + str(e)
        SaveSeed(seed)
        return ""

def executeTranscribe(seed, flvPath):
    try:
        srtPath, file_name, language = transcribe_func(flvPath)
        PushSubtitleToServer(srtPath,file_name) #srt文件推送到服务器
        seed["srt_path"] = srtPath.replace(filePath_prefix_srt,"")
        seed["video_language"] = language
        seed["process_status"] = "8"
        seed["err_msg"]= ""
        SaveSeed(seed)
        subtitle = {}
        subtitle["language"] = utils.language_codes[language]
        subtitle["path"] = srtPath.replace(filePath_prefix_srt,"")
        subtitle["seed_id"] = seed["id"]
        subtitle["format"] = SRT_afterfix
        SaveSubtitle(subtitle)
        if os.path.exists(filePath_prefix_video+flvPath):
            os.remove(filePath_prefix_video+flvPath)
            print("移除视频文件"+filePath_prefix_video+flvPath)
    except Exception as e:
        print("转译异常"+str(e))
        seed["process_status"] = "8e"
        seed["err_msg"] = "转译异常" + str(e)
        SaveSeed(seed)

import threading
import time
new_flvPath = None
new_seed = None
current_flvPath = None
current_seed = None

new_seed = getSeedNeedProcess('download_transcribe')
if new_seed is None:
    print("没有待执行的seed")
    return
threading.Thread(target= executeDownload, args=(new_seed, new_flvPath))

while True:
    try:
        if new_seed is not None and current_seed is None and new_flvPath is not None and current_flvPath is None:
            current_seed = new_seed
            current_flvPath = new_flvPath
            new_seed = getSeedNeedProcess('download_transcribe')
            new_flvPath = None
            if new_seed is None:
                break

            threading.Thread(target= executeDownload, args=(new_seed, new_flvPath))

            executeTranscribe(current_seed, current_flvPath)
            current_seed = None
            current_flvPath = None
        time.sleep(2000)
    except Exception as e:
        print(e)